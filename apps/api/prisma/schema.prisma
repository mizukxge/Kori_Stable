datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model AdminUser {
  id       String @id @default(cuid())
  email    String @unique
  name     String
  password String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions          Session[]
  rightsPresets     RightsPreset[]
  galleries         Gallery[]
  proposals         Proposal[]
  proposalTemplates ProposalTemplate[] @relation("CreatedProposalTemplates")
  proposalEmailTemplates ProposalEmailTemplate[]
  contractTemplates ContractTemplate[]
  contracts         Contract[]
  invoices          Invoice[]
  reconciliations   Reconciliation[]
  releases          Release[]
  auditLogs         AuditLog[]
  assets            Asset[]

  closedPeriods      AccountingPeriod[]  @relation("ClosedPeriods")
  lockedPeriods      AccountingPeriod[]  @relation("LockedPeriods")
  unlockedPeriods    AccountingPeriod[]  @relation("UnlockedPeriods")
  createdJournals    JournalEntry[]      @relation("CreatedJournals")
  postedJournals     JournalEntry[]      @relation("PostedJournals")
  approvedJournals   JournalEntry[]      @relation("ApprovedJournals")
  journalAttachments JournalAttachment[]

  // Records relations
  archivedRecords     Record[]          @relation("ArchivedRecords")
  disposedRecords     Record[]          @relation("DisposedRecords")
  legalHoldRecords    Record[]          @relation("LegalHoldRecords")
  retentionPolicies   RetentionPolicy[]
  recordVerifications RecordHash[]

  savedFilters SavedFilter[]

  userRoles              UserRole[]
  assignedRoles          UserRole[]       @relation("AssignedRoles")
  grantedRolePermissions RolePermission[]

  notifications           Notification[]
  notificationPreferences NotificationPreference[]
  notificationDigests     NotificationDigest[]
  webhookEndpoints        WebhookEndpoint[]

  settings       Setting[]
  settingHistory SettingHistory[]

  // Phase 3: Multi-signature envelope system
  createdEnvelopes  Envelope[]          @relation("CreatedEnvelopes")
  envelopeWebhooks  EnvelopeWebhook[]   @relation("CreatedEnvelopeWebhooks")

  @@map("admin_users")
}

enum Role {
  SUPER_ADMIN
  ADMIN
  USER
}

// Sessions - User authentication sessions
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  user AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

// Clients - Customer/Client records
model Client {
  id      String       @id @default(cuid())
  name    String
  email   String       @unique
  phone   String?
  company String?
  status  ClientStatus @default(ACTIVE)
  clientType ClientType?

  // Address information
  address String?
  city    String?
  state   String?
  zipCode String?
  country String? @default("US")

  // Client source & communication preferences
  source                String? // "website", "referral", "social", "direct", etc.
  preferredContactMethod String? // "email", "phone", "both"

  // Metadata
  notes String?
  tags  String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  auditLogs AuditLog[]

  assets       Asset[]
  releases     Release[]
  galleries    Gallery[]
  proposals    Proposal[]
  contracts    Contract[]
  invoices     Invoice[]
  Record       Record[]
  inquiries    Inquiry[]
  appointments Appointment[] @relation("ClientAppointments")

  @@index([email])
  @@index([status])
  @@map("clients")
}

enum ClientStatus {
  ACTIVE
  INACTIVE
  PENDING
  ARCHIVED
}

enum ClientType {
  individual
  business
  organization
}

// ============================================
// LEAD CAPTURE & INQUIRY SYSTEM
// ============================================

// Inquiry - Client inquiry/lead from public form
model Inquiry {
  id                String      @id @default(cuid())

  // Contact Information
  fullName          String      @db.VarChar(255)
  email             String
  phone             String
  company           String?     @db.VarChar(255)

  // Inquiry Details
  inquiryType       InquiryType
  shootDate         DateTime?
  shootDescription  String      @db.Text
  location          String?     @db.VarChar(255)
  specialRequirements String?   @db.Text

  // Budget Information
  budgetMin         Decimal?    @db.Decimal(10, 2)
  budgetMax         Decimal?    @db.Decimal(10, 2)

  // Files & Attachments
  attachmentUrls    String[]    @default([])
  attachmentCount   Int         @default(0)

  // Inquiry Source & Tags
  source            String?     // "website", "google", "referral", etc.
  tags              String[]    @default([])

  // Status & Workflow
  status            InquiryStatus  @default(NEW)
  internalNotes     String?     @db.Text

  // Relationships
  clientId          String?     // Links to existing/converted client
  client            Client?     @relation(fields: [clientId], references: [id], onDelete: SetNull)

  // Timestamps
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  contactedAt       DateTime?
  qualifiedAt       DateTime?
  convertedAt       DateTime?

  // Metadata
  ipAddress         String?
  userAgent         String?

  @@index([email])
  @@index([status])
  @@index([createdAt])
  @@index([clientId])
  @@map("inquiries")
}

enum InquiryType {
  WEDDING
  PORTRAIT
  COMMERCIAL
  EVENT
  FAMILY
  PRODUCT
  REAL_ESTATE
  HEADSHOT
  OTHER
}

enum InquiryStatus {
  NEW
  CONTACTED
  QUALIFIED
  PROPOSAL_SENT
  NEGOTIATING
  CONVERTED
  REJECTED
  ARCHIVED
}

// Audit Log - Activity tracking
model AuditLog {
  id         String  @id @default(cuid())
  action     String // e.g., "CREATE", "UPDATE", "DELETE", "LOGIN"
  entityType String // e.g., "Client", "AdminUser", "Session"
  entityId   String? // ID of the affected entity

  userId   String? // Who performed the action
  clientId String? // Related client (if applicable)

  // Details
  changes   Json? // Store before/after state
  metadata  Json? // Additional context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  user   AdminUser? @relation(fields: [userId], references: [id], onDelete: SetNull)
  client Client?    @relation(fields: [clientId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([clientId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@map("audit_logs")
}

// Assets - Uploaded files (RAW/EDIT/VIDEO)
model Asset {
  id         String        @id @default(cuid())
  filename   String // Original filename
  storedName String        @unique // Unique filename on disk
  filepath   String // Full path to file
  mimeType   String // MIME type (image/jpeg, video/mp4, etc.)
  size       BigInt // File size in bytes
  checksum   String        @unique // SHA256 hash
  category   AssetCategory

  // Metadata
  width    Int?
  height   Int?
  duration Float? // Video duration in seconds
  metadata Json? // EXIF and other metadata

  // Associations
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  uploadedBy     String
  uploadedByUser AdminUser @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)

  galleries    GalleryAsset[]
  galleryCover Gallery[]      @relation("GalleryCoverPhoto")

  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  Selection Selection[]
  Comment   Comment[]

  @@index([clientId])
  @@index([uploadedBy])
  @@index([category])
  @@index([checksum])
  @@map("assets")
}

enum AssetCategory {
  RAW
  EDIT
  VIDEO
}

// Rights Presets - Copyright and usage rights templates
model RightsPreset {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?

  // Copyright fields
  creator         String
  copyrightNotice String
  usageRights     String
  creditLine      String?
  instructions    String?

  // Location defaults
  city    String?
  state   String?
  country String?

  // Tags
  keywords String[] @default([])

  isDefault Boolean @default(false)
  isActive  Boolean @default(true)

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("rights_presets")
}

// Model/Property Releases
model Release {
  id          String      @id @default(cuid())
  type        ReleaseType
  releaseName String // Name of person or property
  releaseDate DateTime?
  expiryDate  DateTime?

  // File storage
  documentPath String? // Path to signed release document
  notes        String?

  // Associations
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  uploadedBy     String
  uploadedByUser AdminUser @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clientId])
  @@index([type])
  @@map("releases")
}

enum ReleaseType {
  MODEL
  PROPERTY
}

// Galleries - Public shareable collections
model Gallery {
  id          String    @id @default(cuid())
  token       String    @unique // URL token for public access
  name        String
  description String?
  password    String? // Hashed password (optional)
  expiresAt   DateTime? // Gallery expiration
  isActive    Boolean   @default(true)

  // Associations
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  // Assets in this gallery (many-to-many)
  assets GalleryAsset[]

  // Cover photo
  coverPhotoId String?
  coverPhoto   Asset?  @relation("GalleryCoverPhoto", fields: [coverPhotoId], references: [id], onDelete: SetNull)

  // Proofing sessions
  proofSets ProofSet[]

  // Stats
  viewCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([token])
  @@index([clientId])
  @@index([expiresAt])
  @@map("galleries")
}

// Join table for Gallery <-> Asset many-to-many relationship
model GalleryAsset {
  id         String  @id @default(cuid())
  galleryId  String
  assetId    String
  position   Int     @default(0) // Order in gallery
  isFavorite Boolean @default(false) // Favorite in this gallery

  gallery Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  asset   Asset   @relation(fields: [assetId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([galleryId, assetId])
  @@index([galleryId])
  @@index([assetId])
  @@map("gallery_assets")
}

// Proposals - Client proposals with e-signature
model Proposal {
  id             String  @id @default(cuid())
  proposalNumber String  @unique // e.g., PROP-2025-001
  title          String
  description    String?

  // Client association
  clientId String
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // Pricing
  subtotal  Decimal @db.Decimal(10, 2)
  taxRate   Decimal @default(0) @db.Decimal(5, 2)
  taxAmount Decimal @default(0) @db.Decimal(10, 2)
  total     Decimal @db.Decimal(10, 2)
  currency  String  @default("GBP")

  // Terms
  terms      String? // Terms and conditions
  expiresAt  DateTime? // Proposal expiration
  validUntil String? // Human-readable validity

  // Status
  status     ProposalStatus @default(DRAFT)
  sentAt     DateTime?
  viewedAt   DateTime?
  acceptedAt DateTime?
  declinedAt DateTime?

  // E-signature tracking
  signatureIP    String?
  signatureAgent String? // User agent string
  otpCode        String? // Current OTP for acceptance
  otpExpiresAt   DateTime? // OTP expiration
  otpAttempts    Int       @default(0)

  // Line items
  items ProposalItem[]

  // Contract relationship
  contract Contract?

  // Appointments relationship
  appointments Appointment[] @relation("ProposalAppointments")

  // Email template tracking
  emailTemplateId String?
  emailTemplate   ProposalEmailTemplate? @relation(fields: [emailTemplateId], references: [id], onDelete: SetNull)

  // Metadata
  notes   String? // Internal notes
  pdfPath String? // Generated PDF location

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clientId])
  @@index([status])
  @@index([proposalNumber])
  @@map("proposals")
}

// Proposal Line Items
model ProposalItem {
  id         String   @id @default(cuid())
  proposalId String
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)

  position    Int     @default(0) // Order in proposal
  description String
  quantity    Int     @default(1)
  unitPrice   Decimal @db.Decimal(10, 2)
  amount      Decimal @db.Decimal(10, 2) // quantity * unitPrice

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([proposalId])
  @@map("proposal_items")
}

enum ProposalStatus {
  DRAFT
  SENT
  VIEWED
  ACCEPTED
  DECLINED
  EXPIRED
}

// Proposal Templates - Reusable proposal templates
model ProposalTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?

  // Template content
  title       String? // Default title for proposals created from this template
  defaultTerms String? @db.Text // Default terms and conditions

  // Status
  isActive    Boolean @default(true)
  isPublic    Boolean @default(false) // Shared templates

  // Line items
  items ProposalTemplateItem[]

  // Creator
  createdBy     String
  createdByUser AdminUser @relation("CreatedProposalTemplates", fields: [createdBy], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdBy])
  @@index([isActive])
  @@map("proposal_templates")
}

// Proposal Template Line Items
model ProposalTemplateItem {
  id         String   @id @default(cuid())
  templateId String
  template   ProposalTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  position    Int     @default(0) // Order in template
  description String
  quantity    Int     @default(1)
  unitPrice   Decimal @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
  @@map("proposal_template_items")
}

// ============================================
// CONTRACTS & DOCUMENT MANAGEMENT SYSTEM
// ============================================

// Document Types
enum DocumentType {
  SERVICE_AGREEMENT
  BOOKING_CONTRACT
  LICENSE_AGREEMENT
  MODEL_RELEASE_ADULT
  NDA
  SUBCONTRACTOR_AGREEMENT
  PRIVACY_CONSENT
}

// Event Types for photography
enum EventType {
  WEDDING
  BRAND_EDITORIAL
  EVENT
  PORTRAIT
  COMMERCIAL
}

// Clause - Reusable contract clauses
model Clause {
  id        String   @id @default(cuid())
  slug      String   @unique
  title     String
  bodyHtml  String   @db.Text
  tags      String[] @default([])
  mandatory Boolean  @default(false)
  isActive  Boolean  @default(true)

  // Conditional logic rules
  rules ClauseRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([mandatory])
  @@map("clauses")
}

// ClauseRule - Conditional logic for auto-inserting clauses
model ClauseRule {
  id         String  @id @default(cuid())
  clauseId   String
  clause     Clause  @relation(fields: [clauseId], references: [id], onDelete: Cascade)
  expression Json // JSONLogic expression
  enabled    Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clauseId])
  @@map("clause_rules")
}

// Contract Templates - Enhanced with clause library
model ContractTemplate {
  id          String        @id @default(cuid())
  name        String        @unique
  description String?
  type        DocumentType?
  eventType   EventType?

  // Template content
  content  String? @db.Text // Legacy: Template content with {{variables}}
  bodyHtml String? @db.Text // HTML content for PDF generation

  // Variables metadata with validation rules
  variables       Json? // Legacy: List of available variables
  variablesSchema Json? // Enhanced: { name, type, required, validation, mask, default }

  // Clause references
  mandatoryClauseIds String[] @default([]) // IDs of mandatory clauses

  // Status
  isActive    Boolean @default(true)
  isPublished Boolean @default(false)
  version     Int     @default(1)

  // Generated contracts
  contracts Contract[]

  // Pricing rules linked to this template
  pricingRules PricingRule[]

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([type])
  @@index([eventType])
  @@index([isPublished])
  @@map("contract_templates")
}

// Contract Status with full e-signing lifecycle
enum ContractStatus {
  DRAFT
  SENT
  VIEWED
  SIGNED
  COUNTERSIGNED
  ACTIVE
  EXPIRED
  TERMINATED
  VOIDED
  CANCELLED
}

// Contracts - Enhanced with e-signing workflow
model Contract {
  id             String @id @default(cuid())
  contractNumber String @unique // e.g., CT-2025-0001
  title          String

  // Numbering for reissues
  baseNumber   String? // e.g., CT-2025-0001
  reissueIndex Int     @default(0) // 0 = original, 1 = -R1, 2 = -R2

  // Template reference
  templateId      String?
  template        ContractTemplate? @relation(fields: [templateId], references: [id], onDelete: Restrict)
  templateVersion Int?              @default(1)

  // Generated content
  content  String? @db.Text // Legacy: Final content with variables replaced
  bodyHtml String? @db.Text // HTML content for PDF

  variables Json? // Actual variable values used

  // Associations
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  proposalId String?   @unique
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)

  // Invoices linked to this contract
  invoices Invoice[]

  // Appointments relationship
  appointments Appointment[] @relation("ContractAppointments")

  // Contract dates
  signByAt    DateTime?
  effectiveAt DateTime?
  timezone    String    @default("Europe/London")

  // E-signing: OTP verification
  otpEmail     String?
  otpCode      String?
  otpExpiresAt DateTime?

  // E-signing: Portal access
  portalPasswordHash String?
  magicLinkToken     String?   @unique
  magicLinkExpiresAt DateTime?
  failedAttempts     Int       @default(0)

  // E-signing: Signer session
  signerSessionId        String?
  signerSessionExpiresAt DateTime?

  // Document storage and verification
  pdfPath          String? // PDF file path
  pdfHash          String? // SHA-256 hash for integrity verification
  pdfGeneratedAt   DateTime? // PDF generation timestamp
  pdfPathEncrypted String? // Encrypted PDF path (future)
  snapshotJsonEncrypted String? // Encrypted immutable snapshot (future)
  ocrTextPath      String? // Sidecar OCR text file (future)
  sha256           String? // Legacy PDF hash field

  // Status tracking
  status          ContractStatus @default(DRAFT)
  sentAt          DateTime?
  viewedAt        DateTime?
  signedAt        DateTime?
  countersignedAt DateTime?
  voidedAt        DateTime?
  voidedReason    String?

  // Invoice automation
  needsInvoiceRetry    Boolean @default(false)
  invoiceFailureReason String?

  // Audit trail
  events ContractEvent[]

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contractNumber])
  @@index([baseNumber])
  @@index([clientId])
  @@index([templateId])
  @@index([status])
  @@index([signByAt])
  @@index([magicLinkToken])
  @@index([sha256])
  @@map("contracts")
}

// Contract Events - Full audit trail
enum ContractEventType {
  CREATED
  SENT
  VIEWED
  SIGNED
  COUNTERSIGNED
  EXPIRED
  VOIDED
  LINK_LOCKED
  REMINDER_SENT
  PDF_VIEWED
  PASSWORD_FAILED
  OTP_SENT
  OTP_VERIFIED
  SESSION_STARTED
  SESSION_EXPIRED
  REISSUED
  REACTIVATED
}

model ContractEvent {
  id         String            @id @default(cuid())
  contractId String
  contract   Contract          @relation(fields: [contractId], references: [id], onDelete: Cascade)
  type       ContractEventType
  ip         String? // Hashed IP address
  userAgent  String? // Hashed user agent
  meta       Json? // Additional metadata

  createdAt DateTime @default(now())

  @@index([contractId])
  @@index([type])
  @@index([createdAt])
  @@map("contract_events")
}

// Contract Reminder Rules
model ContractReminderRule {
  id                String  @id @default(cuid())
  name              String
  offsetsDays       Int[] // e.g., [-3, 0, 3, 7] for T-3, T, T+3, T+7
  businessHoursOnly Boolean @default(true)
  cooldownHours     Int     @default(24)
  isActive          Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("contract_reminder_rules")
}

// Pricing Rules - Auto-invoice creation on signature
model PricingRule {
  id         String            @id @default(cuid())
  key        String            @unique // event_type or template_id
  eventType  EventType?
  templateId String?
  template   ContractTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)

  depositPercent     Decimal @default(50) @db.Decimal(5, 2)
  finalDueOffsetDays Int     @default(30)
  notes              String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([eventType])
  @@index([templateId])
  @@map("pricing_rules")
}

// Invoices - Client invoicing
model Invoice {
  id            String  @id @default(cuid())
  invoiceNumber String  @unique // e.g., INV-2025-001
  title         String
  description   String?

  // Client association
  clientId String
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // Contract linkage (for invoices auto-created from contracts)
  contractId String?
  contract   Contract? @relation(fields: [contractId], references: [id], onDelete: SetNull)

  // Pricing
  subtotal   Decimal @db.Decimal(10, 2)
  taxRate    Decimal @default(0) @db.Decimal(5, 2)
  taxAmount  Decimal @default(0) @db.Decimal(10, 2)
  total      Decimal @db.Decimal(10, 2)
  amountPaid Decimal @default(0) @db.Decimal(10, 2)
  amountDue  Decimal @db.Decimal(10, 2)
  currency   String  @default("GBP")

  // Payment terms
  dueDate      DateTime?
  paymentTerms String? // e.g., "Net 30", "Due on Receipt"
  notes        String?

  // Payment configuration
  paymentType PaymentType? // CASH or CARD (selected by admin when sending invoice)

  // Status
  status InvoiceStatus @default(DRAFT)
  sentAt DateTime?
  paidAt DateTime?

  // Line items and payments
  items    InvoiceItem[]
  payments Payment[]

  // Appointments relationship
  appointments Appointment[] @relation("InvoiceAppointments")

  // PDF
  pdfPath String?

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invoiceNumber])
  @@index([clientId])
  @@index([contractId])
  @@index([status])
  @@index([dueDate])
  @@map("invoices")
}

// Invoice Line Items
model InvoiceItem {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  position    Int     @default(0)
  description String
  quantity    Int     @default(1)
  unitPrice   Decimal @db.Decimal(10, 2)
  amount      Decimal @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invoiceId])
  @@map("invoice_items")
}

// Payments - Payment transactions
model Payment {
  id            String @id @default(cuid())
  paymentNumber String @unique // e.g., PAY-2025-001

  // Invoice association
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Payment details
  amount   Decimal       @db.Decimal(10, 2)
  currency String        @default("GBP")
  method   PaymentMethod @default(BANK_TRANSFER)
  status   PaymentStatus @default(PENDING)

  // External payment processor
  stripePaymentId String? @unique
  stripeIntentId  String?

  // Metadata
  paidAt       DateTime?
  refundedAt   DateTime?
  refundAmount Decimal?  @db.Decimal(10, 2)
  notes        String?

  // Reconciliation
  reconciliation Reconciliation?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invoiceId])
  @@index([status])
  @@index([stripePaymentId])
  @@map("payments")
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  PARTIAL
  OVERDUE
  CANCELLED
}

enum PaymentType {
  CASH
  CARD
}

enum PaymentMethod {
  CREDIT_CARD
  BANK_TRANSFER
  CHECK
  CASH
  STRIPE
  PAYPAL
  APPLE_PAY
  GOOGLE_PAY
  OTHER
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

// Bank Transactions - Imported from bank statements
model BankTransaction {
  id String @id @default(cuid())

  // Transaction details
  transactionDate DateTime
  description     String
  amount          Decimal  @db.Decimal(10, 2)
  currency        String   @default("GBP")
  reference       String? // Bank reference number

  // Bank account info
  bankAccount   String?
  accountNumber String?

  // Import metadata
  importBatch String // Group transactions by import batch
  rawData     Json? // Original CSV row for reference

  // Reconciliation
  reconciled     Boolean         @default(false)
  reconciledAt   DateTime?
  reconciliation Reconciliation?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transactionDate])
  @@index([amount])
  @@index([importBatch])
  @@index([reconciled])
  @@map("bank_transactions")
}

// Reconciliation - Matches between bank transactions and payments
model Reconciliation {
  id String @id @default(cuid())

  // Bank transaction
  bankTransactionId String          @unique
  bankTransaction   BankTransaction @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)

  // System payment (if matched)
  paymentId String?  @unique
  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  // Matching details
  matchType     MatchType  @default(MANUAL)
  confidence    Int        @default(0) // 0-100%
  matchedBy     String? // User who confirmed match
  matchedByUser AdminUser? @relation(fields: [matchedBy], references: [id], onDelete: SetNull)

  // Status
  status ReconciliationStatus @default(PENDING)
  notes  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([matchType])
  @@map("reconciliations")
}

enum MatchType {
  AUTO_EXACT // Exact amount and date match
  AUTO_FUZZY // Fuzzy match with high confidence
  MANUAL // Manually matched by user
  SUGGESTED // System suggestion, needs confirmation
}

enum ReconciliationStatus {
  PENDING // Not yet confirmed
  CONFIRMED // Match confirmed
  REJECTED // Match rejected
  UNMATCHED // No match found
}

// Accounting Periods - Monthly/quarterly/yearly accounting periods
model AccountingPeriod {
  id         String     @id @default(cuid())
  name       String     @unique // e.g., "2025-01", "2025-Q1", "2025"
  periodType PeriodType @default(MONTHLY)

  // Date range
  startDate DateTime
  endDate   DateTime

  // Status
  status       PeriodStatus @default(OPEN)
  closedAt     DateTime?
  closedBy     String?
  closedByUser AdminUser?   @relation("ClosedPeriods", fields: [closedBy], references: [id], onDelete: SetNull)

  lockedAt     DateTime?
  lockedBy     String?
  lockedByUser AdminUser? @relation("LockedPeriods", fields: [lockedBy], references: [id], onDelete: SetNull)

  // Unlock tracking
  unlockedAt     DateTime?
  unlockedBy     String?
  unlockedByUser AdminUser? @relation("UnlockedPeriods", fields: [unlockedBy], references: [id], onDelete: SetNull)
  unlockReason   String?

  // Journal entries
  journalEntries JournalEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([startDate])
  @@index([endDate])
  @@index([status])
  @@map("accounting_periods")
}

// Journal Entries - General ledger journal entries
model JournalEntry {
  id            String @id @default(cuid())
  journalNumber String @unique // e.g., JE-2025-001

  // Period association
  periodId String
  period   AccountingPeriod @relation(fields: [periodId], references: [id], onDelete: Restrict)

  // Entry details
  entryDate   DateTime
  description String
  reference   String? // External reference (invoice, payment, etc.)

  // Lines (debits and credits)
  lines JournalLine[]

  // Attachments
  attachments JournalAttachment[]

  // Status
  status       JournalStatus @default(DRAFT)
  postedAt     DateTime?
  postedBy     String?
  postedByUser AdminUser?    @relation("PostedJournals", fields: [postedBy], references: [id], onDelete: SetNull)

  // Approval workflow
  approvedAt     DateTime?
  approvedBy     String?
  approvedByUser AdminUser? @relation("ApprovedJournals", fields: [approvedBy], references: [id], onDelete: SetNull)

  createdBy     String
  createdByUser AdminUser @relation("CreatedJournals", fields: [createdBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([periodId])
  @@index([entryDate])
  @@index([status])
  @@index([journalNumber])
  @@map("journal_entries")
}

// Journal Lines - Individual debit/credit lines
model JournalLine {
  id             String       @id @default(cuid())
  journalEntryId String
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)

  position    Int     @default(0)
  account     String // Account code/name
  description String?

  // Amount
  debit  Decimal @default(0) @db.Decimal(10, 2)
  credit Decimal @default(0) @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([journalEntryId])
  @@map("journal_lines")
}

// Journal Attachments - Supporting documents
model JournalAttachment {
  id             String       @id @default(cuid())
  journalEntryId String
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)

  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String

  description String?

  uploadedBy     String
  uploadedByUser AdminUser @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([journalEntryId])
  @@map("journal_attachments")
}

enum PeriodType {
  MONTHLY
  QUARTERLY
  YEARLY
}

enum PeriodStatus {
  OPEN
  CLOSED
  LOCKED
}

enum JournalStatus {
  DRAFT
  POSTED
  APPROVED
  VOIDED
}

// Records - Immutable archived files with WORM compliance
model Record {
  id           String @id @default(cuid())
  recordNumber String @unique // e.g., REC-2025-001

  // File information
  filename     String
  originalPath String
  archivePath  String @unique // Immutable storage location
  mimeType     String
  size         BigInt

  // Cryptographic hash (SHA256)
  hash          String @unique
  hashAlgorithm String @default("SHA256")

  // Record metadata
  description String?
  category    RecordCategory @default(DOCUMENT)
  tags        String[]       @default([])

  // Retention policy
  retentionPolicyId String?
  retentionPolicy   RetentionPolicy? @relation(fields: [retentionPolicyId], references: [id], onDelete: SetNull)

  retainUntil     DateTime? // Calculated retention date
  legalHold       Boolean    @default(false) // Prevents deletion
  legalHoldReason String?
  legalHoldBy     String?
  legalHoldByUser AdminUser? @relation("LegalHoldRecords", fields: [legalHoldBy], references: [id], onDelete: SetNull)
  legalHoldAt     DateTime?

  // Verification history
  verifications      RecordHash[]
  lastVerifiedAt     DateTime?
  verificationStatus VerificationStatus @default(PENDING)

  // Associations
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  // Audit trail
  archivedBy     String
  archivedByUser AdminUser @relation("ArchivedRecords", fields: [archivedBy], references: [id], onDelete: Restrict)
  archivedAt     DateTime  @default(now())

  // Disposal (if retention expired and no legal hold)
  disposedAt     DateTime?
  disposedBy     String?
  disposedByUser AdminUser? @relation("DisposedRecords", fields: [disposedBy], references: [id], onDelete: SetNull)
  disposalReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([recordNumber])
  @@index([hash])
  @@index([category])
  @@index([retainUntil])
  @@index([legalHold])
  @@index([verificationStatus])
  @@map("records")
}

// Retention Policies - Compliance and legal retention rules
model RetentionPolicy {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?

  // Retention period
  retentionYears  Int @default(7) // e.g., 7 years for tax records
  retentionMonths Int @default(0) // Additional months
  retentionDays   Int @default(0) // Additional days

  // Policy details
  regulatoryBasis String? // e.g., "IRS Tax Records", "GDPR", "HIPAA"
  category        RecordCategory?

  // Status
  isActive  Boolean @default(true)
  isDefault Boolean @default(false)

  // Records using this policy
  records Record[]

  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([isActive])
  @@map("retention_policies")
}

// Record Hashes - Verification history
model RecordHash {
  id String @id @default(cuid())

  recordId String
  record   Record @relation(fields: [recordId], references: [id], onDelete: Cascade)

  // Hash verification
  computedHash String // Hash computed during verification
  expectedHash String // Original hash from record
  matched      Boolean // Whether hashes matched

  // Verification details
  verifiedAt     DateTime   @default(now())
  verifiedBy     String? // User or system
  verifiedByUser AdminUser? @relation(fields: [verifiedBy], references: [id], onDelete: SetNull)

  // File state at verification
  fileExists Boolean
  fileSize   BigInt?

  // Error details if verification failed
  error String?

  @@index([recordId])
  @@index([verifiedAt])
  @@index([matched])
  @@map("record_hashes")
}

enum RecordCategory {
  DOCUMENT // General documents
  CONTRACT // Legal contracts
  INVOICE // Financial invoices
  TAX // Tax records
  PHOTO // Photography files
  VIDEO // Video files
  CORRESPONDENCE // Emails, letters
  LEGAL // Legal documents
  COMPLIANCE // Compliance records
  OTHER
}

enum VerificationStatus {
  PENDING // Not yet verified
  VERIFIED // Hash verified successfully
  FAILED // Hash verification failed (tampered)
  ERROR // Error during verification
}

// Magic Link for passwordless authentication
model MagicLink {
  id        String    @id @default(cuid())
  email     String
  tokenHash String    @unique // SHA256 hash of the token
  purpose   String // 'admin_login', 'client_login', 'client_portal'
  expiresAt DateTime
  usedAt    DateTime?
  ipHash    String? // SHA256 hash of requesting IP
  uaHash    String? // SHA256 hash of user agent
  metadata  Json? // Additional context
  createdAt DateTime  @default(now())

  @@index([email])
  @@index([tokenHash])
  @@index([expiresAt])
  @@map("magic_links")
}

// ============================================
// PROOFING & SELECTION WORKFLOW
// ============================================

// ProofSet - A client's proofing session for a gallery
model ProofSet {
  id        String  @id @default(cuid())
  galleryId String
  gallery   Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)

  // Session tracking
  startedAt    DateTime  @default(now())
  completedAt  DateTime?
  lastActiveAt DateTime  @default(now())

  // Client info (captured at session start)
  clientEmail String?
  clientName  String?
  ipAddress   String?
  userAgent   String?

  // Selections and comments
  selections Selection[]
  comments   Comment[]

  // Stats
  totalViewed   Int @default(0)
  totalSelected Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([galleryId])
  @@index([clientEmail])
  @@map("proof_sets")
}

// Selection - Client selections (hearts, flags, rejects)
model Selection {
  id         String   @id @default(cuid())
  proofSetId String
  proofSet   ProofSet @relation(fields: [proofSetId], references: [id], onDelete: Cascade)

  assetId String
  asset   Asset  @relation(fields: [assetId], references: [id], onDelete: Cascade)

  type SelectionType @default(HEART)

  // Metadata
  note String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([proofSetId, assetId]) // One selection per asset per proof set
  @@index([proofSetId])
  @@index([assetId])
  @@index([type])
  @@map("selections")
}

enum SelectionType {
  HEART // Client loves this photo
  FLAG // Client wants to discuss this photo
  REJECT // Client doesn't want this photo
}

// Comment - Client comments on individual photos
model Comment {
  id         String   @id @default(cuid())
  proofSetId String
  proofSet   ProofSet @relation(fields: [proofSetId], references: [id], onDelete: Cascade)

  assetId String
  asset   Asset  @relation(fields: [assetId], references: [id], onDelete: Cascade)

  text String @db.Text

  // Reply tracking (for future use)
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  // Edit tracking
  edited   Boolean   @default(false)
  editedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([proofSetId])
  @@index([assetId])
  @@index([parentId])
  @@map("comments")
}

// ============================================
// SEARCH & FILTERS
// ============================================

// SavedFilter - User's saved search filters
model SavedFilter {
  id     String    @id @default(cuid())
  userId String
  user   AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Filter details
  name        String
  description String?

  // Search query
  query      String? // Search query text
  entityType String // 'client', 'asset', 'document', 'invoice', etc.

  // Filter criteria (JSON)
  filters Json // Facets: status, category, dateRange, tags, etc.

  // Usage tracking
  isDefault  Boolean   @default(false)
  lastUsedAt DateTime?
  usageCount Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([entityType])
  @@map("saved_filters")
}

// ============================================
// RBAC & PERMISSIONS
// ============================================

// SystemRole - Predefined system roles
model SystemRole {
  id          String  @id @default(cuid())
  name        String  @unique // SUPER_ADMIN, ADMIN, EDITOR, VIEWER, etc.
  displayName String // Human-readable name
  description String?

  // Role hierarchy level (higher = more permissions)
  level Int @default(0)

  // System flags
  isSystem  Boolean @default(false) // Cannot be deleted
  isDefault Boolean @default(false) // Assigned to new users
  isActive  Boolean @default(true)

  // Permissions
  permissions RolePermission[]

  // User assignments
  userRoles UserRole[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([level])
  @@map("system_roles")
}

// UserRole - Many-to-many relationship between users and roles
model UserRole {
  id     String    @id @default(cuid())
  userId String
  user   AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  roleId String
  role   SystemRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  // Assignment metadata
  assignedBy     String?
  assignedByUser AdminUser? @relation("AssignedRoles", fields: [assignedBy], references: [id], onDelete: SetNull)
  assignedAt     DateTime   @default(now())

  // Scope (optional - for limiting role to specific resources)
  scope     String? // e.g., "client:abc123" to limit to one client
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, roleId, scope]) // User can have same role with different scopes
  @@index([userId])
  @@index([roleId])
  @@map("user_roles")
}

// Permission - Granular permission definitions
model Permission {
  id       String @id @default(cuid())
  resource String // Resource type: "clients", "invoices", "assets", etc.
  action   String // Action: "create", "read", "update", "delete", "export", etc.

  // Combined permission name: "clients:read", "invoices:delete"
  name String @unique

  displayName String
  description String?

  // Grouping
  category String? // "Content", "Finance", "Admin", etc.

  // Permission flags
  isSystem    Boolean @default(true) // System-defined permissions
  isActive    Boolean @default(true)
  isDangerous Boolean @default(false) // Requires extra confirmation

  // Role assignments
  rolePermissions RolePermission[]

  // Policy rules
  policyRules PolicyRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([resource, action])
  @@index([name])
  @@index([resource])
  @@map("permissions")
}

// RolePermission - Many-to-many between roles and permissions
model RolePermission {
  id String @id @default(cuid())

  roleId String
  role   SystemRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Grant metadata
  grantedBy     String?
  grantedByUser AdminUser? @relation(fields: [grantedBy], references: [id], onDelete: SetNull)
  grantedAt     DateTime   @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
  @@map("role_permissions")
}

// PolicyRule - Fine-grained access control rules
model PolicyRule {
  id   String @id @default(cuid())
  name String @unique

  // Rule definition
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Rule conditions (JSON-based)
  // Example: { "field": "ownerId", "operator": "equals", "value": "$userId" }
  // Example: { "field": "status", "operator": "in", "value": ["DRAFT", "PENDING"] }
  conditions Json

  // Rule behavior
  effect      PolicyEffect @default(ALLOW) // ALLOW or DENY
  priority    Int          @default(0) // Higher priority = evaluated first
  description String?

  // Status
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([permissionId])
  @@index([priority])
  @@map("policy_rules")
}

enum PolicyEffect {
  ALLOW
  DENY
}

// PermissionCache - Cache for permission checks (optional optimization)
model PermissionCache {
  id String @id @default(cuid())

  userId       String
  permissionId String
  resourceId   String? // Specific resource being accessed

  // Cached result
  hasPermission Boolean

  // Cache metadata
  computedAt DateTime @default(now())
  expiresAt  DateTime

  @@unique([userId, permissionId, resourceId])
  @@index([userId])
  @@index([expiresAt])
  @@map("permission_cache")
}

// ============================================
// NOTIFICATIONS CENTER
// ============================================

// Notification - In-app notifications for users
model Notification {
  id String @id @default(cuid())

  userId String
  user   AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Notification details
  type     NotificationType // Event type
  title    String
  message  String           @db.Text
  category String? // "info", "success", "warning", "error"

  // Related entity
  entityType String? // "invoice", "client", "asset", etc.
  entityId   String?

  // Additional data (JSON)
  metadata Json?

  // Actions
  actionUrl  String? // URL to navigate to
  actionText String? // Button text

  // Status
  isRead      Boolean   @default(false)
  readAt      DateTime?
  isDismissed Boolean   @default(false)
  dismissedAt DateTime?

  // Priority
  priority NotificationPriority @default(NORMAL)

  // Expiration
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([type])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  // Client events
  CLIENT_CREATED
  CLIENT_UPDATED
  CLIENT_MESSAGE

  // Invoice events
  INVOICE_CREATED
  INVOICE_SENT
  INVOICE_PAID
  INVOICE_OVERDUE
  INVOICE_REMINDER

  // Payment events
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  PAYMENT_REFUNDED

  // Contract/Proposal events
  PROPOSAL_CREATED
  PROPOSAL_SENT
  PROPOSAL_VIEWED
  PROPOSAL_ACCEPTED
  PROPOSAL_DECLINED
  CONTRACT_SIGNED
  CONTRACT_EXPIRING

  // Gallery events
  GALLERY_CREATED
  GALLERY_SHARED
  GALLERY_VIEWED
  GALLERY_EXPIRING

  // Proofing events
  PROOF_SELECTION_MADE
  PROOF_COMMENT_ADDED
  PROOF_COMPLETED

  // Asset events
  ASSET_UPLOADED
  ASSET_PROCESSED
  ASSET_FAILED

  // User events
  USER_INVITED
  USER_ROLE_CHANGED

  // System events
  SYSTEM_MAINTENANCE
  SYSTEM_UPDATE
  BACKUP_COMPLETED
  BACKUP_FAILED

  // Custom
  CUSTOM
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// NotificationPreference - User notification subscription settings
model NotificationPreference {
  id String @id @default(cuid())

  userId String
  user   AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Channel preferences
  emailEnabled   Boolean @default(true)
  inAppEnabled   Boolean @default(true)
  webhookEnabled Boolean @default(false)

  // Event-specific preferences
  eventType NotificationType
  enabled   Boolean          @default(true)

  // Digest preferences
  digestEnabled   Boolean                     @default(false)
  digestFrequency NotificationDigestFrequency @default(DAILY)
  digestTime      String? // HH:MM format, e.g., "09:00"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventType])
  @@index([userId])
  @@map("notification_preferences")
}

enum NotificationDigestFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

// NotificationDigest - Scheduled digest emails
model NotificationDigest {
  id String @id @default(cuid())

  userId String
  user   AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  frequency NotificationDigestFrequency

  // Digest content
  notificationIds String[] // Array of notification IDs included
  emailSent       Boolean   @default(false)
  emailSentAt     DateTime?

  // Period covered
  periodStart DateTime
  periodEnd   DateTime

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([emailSent])
  @@index([periodStart])
  @@map("notification_digests")
}

// WebhookEndpoint - Webhook delivery targets
model WebhookEndpoint {
  id String @id @default(cuid())

  userId String
  user   AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Endpoint details
  name        String
  url         String
  secret      String? // Webhook signing secret
  description String?

  // Event subscriptions
  events String[] @default([]) // Array of NotificationType

  // Status
  isActive            Boolean   @default(true)
  isVerified          Boolean   @default(false)
  verifiedAt          DateTime?
  lastPingAt          DateTime?
  lastSuccessAt       DateTime?
  lastFailureAt       DateTime?
  failureCount        Int       @default(0)
  consecutiveFailures Int       @default(0)

  // Retry configuration
  maxRetries     Int @default(3)
  retryBackoff   Int @default(60) // Seconds
  timeoutSeconds Int @default(30)

  // Headers (JSON)
  headers Json?

  // Deliveries
  deliveries WebhookDelivery[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isActive])
  @@map("webhook_endpoints")
}

// WebhookDelivery - Webhook delivery attempts tracking
model WebhookDelivery {
  id String @id @default(cuid())

  endpointId String
  endpoint   WebhookEndpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  // Event details
  eventType NotificationType
  eventId   String // ID of the notification or event
  payload   Json // Full webhook payload

  // Delivery status
  status      WebhookDeliveryStatus @default(PENDING)
  attempts    Int                   @default(0)
  maxAttempts Int                   @default(3)
  nextRetryAt DateTime?

  // Response
  responseStatus Int? // HTTP status code
  responseBody   String? @db.Text
  responseTime   Int? // Milliseconds

  // Error tracking
  error         String?   @db.Text
  lastAttemptAt DateTime?
  succeededAt   DateTime?
  failedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([endpointId])
  @@index([status])
  @@index([nextRetryAt])
  @@index([createdAt])
  @@map("webhook_deliveries")
}

enum WebhookDeliveryStatus {
  PENDING
  SENDING
  SUCCEEDED
  FAILED
  CANCELLED
}

// EmailLog - Track all emails sent
model EmailLog {
  id String @id @default(cuid())

  // Recipient
  to      String
  cc      String?
  bcc     String?
  from    String
  replyTo String?

  // Content
  subject  String
  template String? // Template name if using templates

  // Status
  status       EmailStatus @default(PENDING)
  sentAt       DateTime?
  deliveredAt  DateTime?
  openedAt     DateTime?
  clickedAt    DateTime?
  bouncedAt    DateTime?
  complainedAt DateTime?

  // Tracking
  messageId      String? // Provider message ID
  providerStatus String?
  error          String? @db.Text

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([to])
  @@index([status])
  @@index([createdAt])
  @@map("email_logs")
}

enum EmailStatus {
  PENDING
  SENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  COMPLAINED
  FAILED
}

// ============================================
// ADMIN SETTINGS & ORGANIZATION
// ============================================

// Organization - Main organization/company profile
model Organization {
  id String @id @default(cuid())

  // Basic information
  name      String
  legalName String?
  email     String
  phone     String?
  website   String?

  // Address
  addressLine1 String?
  addressLine2 String?
  city         String?
  state        String?
  postcode     String?
  country      String  @default("GB")

  // Tax information
  vatNumber      String?
  taxId          String?
  defaultTaxRate Decimal @default(20) @db.Decimal(5, 2) // Default VAT rate

  // Branding
  logoUrl        String?
  primaryColor   String? // Hex color
  secondaryColor String?
  accentColor    String?

  // Feature flags
  features Json @default("{}")

  // Settings
  timezone String @default("Europe/London")
  locale   String @default("en-GB")
  currency String @default("GBP")

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("organizations")
}

// Setting - Key-value settings storage
model Setting {
  id String @id @default(cuid())

  // Setting key (unique)
  key String @unique

  // Setting value (JSON for flexibility)
  value Json

  // Metadata
  category    String? // "email", "notification", "branding", etc.
  description String?
  isPublic    Boolean @default(false) // Can be exposed to frontend
  isEncrypted Boolean @default(false) // Is value encrypted

  // Change tracking
  lastChangedBy     String?
  lastChangedByUser AdminUser? @relation(fields: [lastChangedBy], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isPublic])
  @@map("settings")
}

// SettingHistory - Audit log for setting changes
model SettingHistory {
  id String @id @default(cuid())

  settingKey String

  // Change details
  oldValue Json?
  newValue Json

  // Who changed it
  changedBy     String
  changedByUser AdminUser @relation(fields: [changedBy], references: [id], onDelete: Cascade)

  // Additional context
  ipAddress String?
  userAgent String?
  reason    String? // Optional reason for change

  createdAt DateTime @default(now())

  @@index([settingKey])
  @@index([changedBy])
  @@index([createdAt])
  @@map("setting_history")
}

// ============================================
// PROPOSAL EMAIL TEMPLATES
// ============================================

// ProposalEmailTemplate - Email templates for sending proposals
model ProposalEmailTemplate {
  id          String  @id @default(cuid())
  name        String // Template name (e.g., "Standard Proposal Email")
  subject     String // Email subject line (can include {{variables}})
  content     String  @db.Text // HTML email content (can include {{variables}})

  // Status
  isActive    Boolean @default(true)
  isDefault   Boolean @default(false)

  // Tracking
  proposals   Proposal[]

  // Creator
  createdBy     String
  createdByUser AdminUser @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdBy])
  @@index([isActive])
  @@index([isDefault])
  @@map("proposal_email_templates")
}

// ============================================
// PHASE 3: MULTI-SIGNATURE ENVELOPE SYSTEM
// ============================================

// Envelope Status Enum
enum EnvelopeStatus {
  DRAFT
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
  EXPIRED
}

// Signing Workflow Type
enum SigningWorkflow {
  SEQUENTIAL  // ABC order enforced
  PARALLEL    // All can sign concurrently
}

// Signer Status Enum
enum SignerStatus {
  PENDING
  VIEWED
  SIGNED
  DECLINED
  EXPIRED
}

// Signature Status Enum
enum SignatureStatus {
  PENDING
  VIEWED
  SIGNED
  DECLINED
}

// Audit Action Enum
enum AuditAction {
  ENVELOPE_CREATED
  ENVELOPE_SENT
  ENVELOPE_VIEWED
  ENVELOPE_SIGNED
  ENVELOPE_DECLINED
  ENVELOPE_COMPLETED
  ENVELOPE_CANCELLED
  ENVELOPE_EXPIRED
  DOCUMENT_ADDED
  DOCUMENT_REMOVED
  SIGNER_ADDED
  SIGNER_REMOVED
  SIGNER_VIEWED
  SIGNER_SIGNED
  SIGNER_DECLINED
  SIGNATURE_VERIFIED
  TAMPER_DETECTED
}

// Webhook Event Enum
enum WebhookEvent {
  ENVELOPE_CREATED
  ENVELOPE_SENT
  ENVELOPE_VIEWED
  ENVELOPE_SIGNED
  ENVELOPE_DECLINED
  ENVELOPE_COMPLETED
  ENVELOPE_CANCELLED
  ENVELOPE_EXPIRED
  SIGNER_VIEWED
  SIGNER_SIGNED
  SIGNER_DECLINED
}

// ============================================
// ENVELOPE & DOCUMENTS
// ============================================

model Envelope {
  id                String   @id @default(cuid())

  // Naming & metadata
  name              String
  description       String?

  // Creator & access control
  createdById       String
  createdBy         AdminUser @relation("CreatedEnvelopes", fields: [createdById], references: [id], onDelete: Cascade)

  // State management
  status            EnvelopeStatus @default(DRAFT)
  signingWorkflow   SigningWorkflow @default(SEQUENTIAL)

  // Expiration
  expiresAt         DateTime?

  // Timestamps
  sentAt            DateTime?
  completedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  documents         Document[]
  signers           Signer[]
  signatures        Signature[]
  auditLogs         EnvelopeAuditLog[]

  @@index([createdById])
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])
  @@map("envelopes")
}

model Document {
  id                String   @id @default(cuid())

  // Envelope reference
  envelopeId        String
  envelope          Envelope @relation(fields: [envelopeId], references: [id], onDelete: Cascade)

  // Document info
  name              String
  fileName          String
  filePath          String   // Path to stored PDF

  // Integrity verification
  fileHash          String   // SHA256 hash of file
  fileSize          Int      // Size in bytes

  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([envelopeId])
  @@index([fileHash])
  @@map("documents")
}

// ============================================
// SIGNERS & SIGNATURES
// ============================================

model Signer {
  id                String   @id @default(cuid())

  // Envelope reference
  envelopeId        String
  envelope          Envelope @relation(fields: [envelopeId], references: [id], onDelete: Cascade)

  // Signer identity
  name              String
  email             String
  role              String?  // buyer, seller, witness, lawyer, etc.

  // Sequential workflow: signing order
  sequenceNumber    Int?     // 1, 2, 3... for sequential

  // Signing status
  status            SignerStatus @default(PENDING)

  // Magic link authentication
  magicLinkToken    String   @unique
  magicLinkExpiresAt DateTime

  // Session management
  signerSessionId   String?
  signerSessionExpiresAt DateTime?

  // OTP verification (per-signer)
  otpEmail          String?
  otpCode           String?
  otpExpiresAt      DateTime?
  failedAttempts    Int      @default(0)

  // Signing timestamps
  viewedAt          DateTime?
  signedAt          DateTime?
  declinedAt        DateTime?
  declinedReason    String?

  // IP & browser info for audit
  signerIP          String?
  signerUserAgent   String?

  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  signatures        Signature[]

  @@unique([envelopeId, email])
  @@index([envelopeId])
  @@index([status])
  @@index([email])
  @@index([magicLinkToken])
  @@index([envelopeId, sequenceNumber])
  @@map("signers")
}

model Signature {
  id                String   @id @default(cuid())

  // References
  envelopeId        String
  envelope          Envelope @relation(fields: [envelopeId], references: [id], onDelete: Cascade)

  signerId          String
  signer            Signer @relation(fields: [signerId], references: [id], onDelete: Cascade)

  // Status
  status            SignatureStatus @default(PENDING)

  // Signature data
  signatureDataUrl  String?  // Base64 encoded canvas data
  initialsDataUrl   String?  // Optional initials

  // Verification (SHA256 hash of signature data)
  signatureHash     String?

  // Optional: position on document (for multi-page PDFs)
  pageNumber        Int?
  xCoordinate       Float?
  yCoordinate       Float?
  width             Float?
  height            Float?

  // IP & browser info for compliance
  signerIP          String?
  signerUserAgent   String?

  // Timestamps
  signedAt          DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([envelopeId])
  @@index([signerId])
  @@index([status])
  @@index([signedAt])
  @@map("signatures")
}

// ============================================
// AUDIT & COMPLIANCE
// ============================================

model EnvelopeAuditLog {
  id                String   @id @default(cuid())

  // Envelope & signer references
  envelopeId        String
  envelope          Envelope @relation(fields: [envelopeId], references: [id], onDelete: Cascade)

  signerId          String?  // Null for envelope-level events

  // Action & metadata
  action            AuditAction
  metadata          Json?    // Additional context (error msg, old value, new value, etc.)

  // Who performed the action
  actorId           String?  // Admin user ID if performed by admin

  // IP & browser for tracking
  ipAddress         String?
  userAgent         String?

  // Timestamp (immutable, append-only)
  timestamp         DateTime @default(now())

  @@index([envelopeId])
  @@index([action])
  @@index([timestamp])
  @@map("envelope_audit_logs")
}

// ============================================
// WEBHOOKS (for notifications)
// ============================================

model EnvelopeWebhook {
  id                String   @id @default(cuid())

  // Admin who registered
  createdById       String
  createdBy         AdminUser @relation("CreatedEnvelopeWebhooks", fields: [createdById], references: [id], onDelete: Cascade)

  // Webhook configuration
  url               String
  events            WebhookEvent[]
  active            Boolean  @default(true)

  // Retry configuration
  maxRetries        Int      @default(3)
  retryDelaySeconds Int      @default(60)

  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([createdById])
  @@index([active])
  @@map("envelope_webhooks")
}

// ============================================
// APPOINTMENTS & SCHEDULING SYSTEM
// ============================================

enum AppointmentType {
  Introduction
  CreativeDirection
  ContractInvoicing
}

enum AppointmentStatus {
  Draft
  InviteSent
  Booked
  Completed
  Cancelled
  NoShow
  Expired
}

enum AppointmentOutcome {
  Positive
  Neutral
  Negative
}

model Appointment {
  id                    String    @id @default(cuid())
  type                  AppointmentType

  // Scheduling
  scheduledAt           DateTime?
  duration              Int       @default(60)

  // Linking
  clientId              String
  client                Client    @relation("ClientAppointments", fields: [clientId], references: [id], onDelete: Cascade)

  proposalId            String?
  proposal              Proposal? @relation("ProposalAppointments", fields: [proposalId], references: [id], onDelete: SetNull)

  contractId            String?
  contract              Contract? @relation("ContractAppointments", fields: [contractId], references: [id], onDelete: SetNull)

  invoiceId             String?
  invoice               Invoice?  @relation("InvoiceAppointments", fields: [invoiceId], references: [id], onDelete: SetNull)

  // Status
  status                AppointmentStatus @default(Draft)
  outcome               AppointmentOutcome?

  // Meeting details
  teamsLink             String?
  recordingUrl          String?
  recordingConsentGiven Boolean   @default(false)

  // Notes
  adminNotes            String?
  clientNotes           String?
  callSummary           String?
  noShowReason          String?

  // Invitation link
  inviteToken           String?   @unique
  inviteTokenExpiresAt  DateTime?
  inviteTokenUsedAt     DateTime?

  // Audit
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Reminders sent
  clientReminder24Sent  Boolean   @default(false)
  clientReminder15Sent  Boolean   @default(false)
  adminReminder24Sent   Boolean   @default(false)
  adminReminder30Sent   Boolean   @default(false)

  // Relations
  auditLog              AppointmentAuditLog[]

  @@index([clientId])
  @@index([status])
  @@index([scheduledAt])
  @@index([inviteToken])
  @@index([inviteTokenExpiresAt])
  @@map("appointments")
}

model AppointmentAuditLog {
  id              String      @id @default(cuid())
  appointmentId   String
  appointment     Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  action          String
  timestamp       DateTime    @default(now())
  details         Json?

  @@index([appointmentId])
  @@index([timestamp])
  @@map("appointment_audit_logs")
}

model AppointmentBlockedTime {
  id        String   @id @default(cuid())
  startAt   DateTime
  endAt     DateTime
  reason    String

  createdAt DateTime @default(now())

  @@index([startAt])
  @@index([endAt])
  @@map("appointment_blocked_times")
}

model AppointmentSettings {
  id                    String   @id @default(cuid())

  workdayStart          Int      @default(11)
  workdayEnd            Int      @default(16)
  bufferMinutes         Int      @default(15)
  bookingWindowDays     Int      @default(14)
  activeTypes           String[] @default(["Introduction", "CreativeDirection", "ContractInvoicing"])

  timezone              String   @default("Europe/London")

  // Email Templates
  invitationEmailTemplate    String   @default("Hi {clientName},\n\nYou're invited to a {appointmentType} call on {proposedDate} at {proposedTime}.\n\nPlease confirm your availability:\n{bookingLink}\n\nBest regards,\n{adminName}")
  confirmationEmailTemplate  String   @default("Hi {clientName},\n\nYour appointment is confirmed for {confirmedDate} at {confirmedTime}.\n\nTeams Link: {teamsLink}\n\nBest regards,\n{adminName}")
  reminderEmailTemplate      String   @default("Hi {clientName},\n\nReminder: Your appointment is on {appointmentDate} at {appointmentTime}.\n\nTeams Link: {teamsLink}\n\nBest regards,\n{adminName}")
  recipientEmailCC           String?

  // Calendar Sync (Stubs for now, OAuth to be implemented)
  googleCalendarEnabled      Boolean  @default(false)
  outlookCalendarEnabled     Boolean  @default(false)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("appointment_settings")
}
